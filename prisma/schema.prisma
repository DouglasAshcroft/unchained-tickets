generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id        Int      @id @default(autoincrement())
  name      String?
  email     String   @unique @db.Citext
  role      UserRole @default(fan)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Profile fields
  phone              String?
  avatarUrl          String?
  bio                String?   @db.Text
  location           String? // City, State or full address
  favoriteGenres     String[] // Array of genre preferences
  stripeCustomerId   String?  @unique
  defaultPaymentMethodId String? // Stripe payment method ID
  locationEnabled    Boolean  @default(false)
  latitude           Decimal? @db.Decimal(9, 6)
  longitude          Decimal? @db.Decimal(9, 6)

  // Wallet & Onboarding fields
  emailVerified      Boolean  @default(false)
  walletAddress      String?  @unique
  walletProvider     String? // 'coinbase_smart_wallet', 'metamask', 'rainbow', etc.
  createdViaOnramp   Boolean  @default(false)
  onboardingComplete Boolean  @default(false)

  // Relations
  credentials             AuthCredential[]
  sessions                Session[]
  wallets                 UserWallet[]
  userRoles               UserRoleLink[]
  artists                 Artist[]               @relation("ArtistOwner")
  venues                  Venue[]                @relation("VenueOwner")
  tickets                 Ticket[]
  scans                   TicketScan[]           @relation("Scanner")
  payments                Payment[]
  charges                 Charge[]
  completedChecklistItems VenueChecklistStatus[] @relation("VenueChecklistCompletedBy")
  supportSessions         VenueSupportSession[]  @relation("VenueSupportSessions")
  auditLogs               AdminAuditLog[]        @relation("AdminAuditLogs")
  profile                 UserProfile?
  venueStaff              VenueStaff[]
  favoriteArtists         FavoriteArtist[]
  invitedStaff            VenueStaff[]           @relation("StaffInviter")

  @@index([email])
  @@index([stripeCustomerId])
  @@index([walletAddress])
  @@index([createdViaOnramp])
}

model AuthCredential {
  id         Int      @id @default(autoincrement())
  userId     Int
  provider   String
  identifier String?
  secret     String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, provider])
}

model Session {
  id        String   @id @default(cuid())
  userId    Int
  token     String   @unique
  expires   DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Role {
  id              Int              @id @default(autoincrement())
  name            String           @unique
  rolePermissions RolePermission[]
  userRoles       UserRoleLink[]
}

model Permission {
  id              Int              @id @default(autoincrement())
  name            String           @unique
  rolePermissions RolePermission[]
}

model UserRoleLink {
  userId Int
  roleId Int
  role   Role @relation(fields: [roleId], references: [id], onDelete: Cascade)
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, roleId])
}

model RolePermission {
  roleId       Int
  permissionId Int
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId])
}

model Wallet {
  id              Int              @id @default(autoincrement())
  chain           String
  address         String           @unique
  createdAt       DateTime         @default(now())
  mints           NFTMint[]
  users           UserWallet[]
  waitlistSignups WaitlistSignup[]
}

model UserWallet {
  userId    Int
  walletId  Int
  isPrimary Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  wallet    Wallet   @relation(fields: [walletId], references: [id], onDelete: Cascade)

  @@id([userId, walletId])
}

model Artist {
  id          Int      @id @default(autoincrement())
  ownerUserId Int?
  name        String
  slug        String   @unique
  genre       String?
  imageUrl    String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  owner          User?            @relation("ArtistOwner", fields: [ownerUserId], references: [id])
  events         Event[]          @relation("PrimaryArtist")
  eventLinks     EventArtist[]
  favoritedBy    FavoriteArtist[]

  // Performance indexes
  @@index([name]) // For text search
  @@index([genre]) // For genre filtering
}

model Venue {
  id           Int      @id @default(autoincrement())
  ownerUserId  Int?
  name         String
  slug         String   @unique
  city         String?
  state        String?
  capacity     Int?
  addressLine1 String?
  addressLine2 String?
  postalCode   String?
  latitude     Decimal? @db.Decimal(9, 6)
  longitude    Decimal? @db.Decimal(9, 6)
  imageUrl     String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  owner                     User?                     @relation("VenueOwner", fields: [ownerUserId], references: [id])
  events                    Event[]
  clicks                    VenueClick[]
  seatMaps                  VenueSeatMap[]
  checklistStatuses         VenueChecklistStatus[]
  supportSessions           VenueSupportSession[]     @relation("VenueSupportSessions")
  staff                     VenueStaff[]
  posterGenerationRequests  PosterGenerationRequest[]

  // Performance indexes
  @@index([name]) // For text search
  @@index([city]) // For location filtering
  @@index([state]) // For state filtering
  @@index([city, state]) // Composite for location searches
}

model Event {
  id                 Int                      @id @default(autoincrement())
  title              String
  startsAt           DateTime
  endsAt             DateTime?
  venueId            Int
  artistId           Int?
  posterImageUrl     String?
  externalLink       String?
  mapsLink           String?
  status             EventStatus              @default(draft)
  createdAt          DateTime                 @default(now())
  updatedAt          DateTime                 @updatedAt
  featured           Boolean                  @default(false)
  featuredUntil      DateTime?
  viewCount          Int                      @default(0)
  advocacyCount      Int                      @default(0)
  clickThroughs      Int                      @default(0)
  estimatedAdValue   Decimal                  @default(0) @db.Decimal(10, 2)
  eventSource        String                   @default("seed")
  impressions        Int                      @default(0)
  lastImpressionAt   DateTime?
  originalTicketUrl  String?
  venueContactEmail  String?
  venue                     Venue                      @relation(fields: [venueId], references: [id], onDelete: Restrict)
  primaryArtist             Artist?                    @relation("PrimaryArtist", fields: [artistId], references: [id])
  artists                   EventArtist[]
  tickets                   Ticket[]
  charges                   Charge[]
  ticketTypes               EventTicketType[]
  seatMapAssignments        EventSeatMapAssignment[]
  advocacyRequests          AdvocacyRequest[]
  impressionLogs            EventImpression[]
  posterVariants            EventPosterVariant[]
  posterGenerationRequests  PosterGenerationRequest[]
  blockchainRegistry        EventBlockchainRegistry?

  // Performance indexes
  @@index([title])
  @@index([startsAt])
  @@index([status])
  @@index([venueId])
  @@index([artistId])
  @@index([startsAt, status])
  @@index([featured, startsAt])
  @@index([featured, featuredUntil])
  @@index([eventSource])
}

model EventArtist {
  eventId   Int
  artistId  Int
  isPrimary Boolean @default(false)
  sortOrder Int?
  artist    Artist  @relation(fields: [artistId], references: [id], onDelete: Cascade)
  event     Event   @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@id([eventId, artistId])
}

model Ticket {
  id              String                 @id @default(cuid())
  eventId         Int
  userId          Int?
  status          TicketStatus           @default(reserved)
  priceCents      Int?
  currency        String?                @default("USD")
  seatSection     String?
  seatRow         String?
  seat            String?
  qrHash          String?                @unique
  createdAt       DateTime               @default(now())
  updatedAt       DateTime               @updatedAt
  ticketTypeId    Int?
  reservedSeatId  Int?                   @unique
  isGenesisTicket         Boolean                      @default(false) // Genesis Archive ticket (company history)
  charges                 Charge[]
  mints                   NFTMint[]
  payments                Payment[]
  event                   Event                        @relation(fields: [eventId], references: [id], onDelete: Cascade)
  reservedSeat            EventReservedSeat?           @relation(fields: [reservedSeatId], references: [id])
  ticketType              EventTicketType?             @relation(fields: [ticketTypeId], references: [id])
  user                    User?                        @relation(fields: [userId], references: [id])
  perkRedemptions         TicketPerkRedemption[]
  scans                   TicketScan[]
  genesisBlockchainRecord EventBlockchainRegistry?     @relation("GenesisTicket")

  @@unique([eventId, seatSection, seatRow, seat])
  @@index([eventId])
  @@index([userId])
  @@index([status])
  @@index([eventId, status])
  @@index([ticketTypeId])
  @@index([isGenesisTicket])
}

model EventTicketType {
  id            Int                 @id @default(autoincrement())
  eventId       Int
  name          String
  description   String?
  pricingType   PricingType         @default(general_admission)
  priceCents    Int?
  currency      String              @default("USD")
  capacity      Int?
  salesStart    DateTime?
  salesEnd      DateTime?
  isActive      Boolean             @default(true)
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  event               Event                         @relation(fields: [eventId], references: [id], onDelete: Cascade)
  tickets             Ticket[]
  reservedSeats       EventReservedSeat[]
  perks               TicketPerk[]
  posterVariants      EventPosterVariant[]
  tierRegistrations   EventTierBlockchainRegistry[]

  @@index([eventId])
  @@index([pricingType])
  @@index([isActive])
}

model TicketPerk {
  id           Int                    @id @default(autoincrement())
  ticketTypeId Int
  name         String
  description  String?
  instructions String?
  quantity     Int                    @default(1)
  createdAt    DateTime               @default(now())
  updatedAt    DateTime               @updatedAt
  ticketType   EventTicketType        @relation(fields: [ticketTypeId], references: [id], onDelete: Cascade)
  redemptions  TicketPerkRedemption[]

  @@index([ticketTypeId])
}

model TicketPerkRedemption {
  id               Int        @id @default(autoincrement())
  ticketId         String
  ticketPerkId     Int
  redeemedQuantity Int        @default(0)
  lastRedeemedAt   DateTime?
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt
  ticket           Ticket     @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  perk             TicketPerk @relation(fields: [ticketPerkId], references: [id], onDelete: Cascade)

  @@unique([ticketId, ticketPerkId])
  @@index([ticketPerkId])
}

model VenueSeatMap {
  id               Int                      @id @default(autoincrement())
  venueId          Int
  name             String
  description      String?
  status           SeatMapStatus            @default(draft)
  version          Int                      @default(1)
  storagePath      String?
  originalFileName String?
  mimeType         String?
  structure        Json?
  createdAt        DateTime                 @default(now())
  updatedAt        DateTime                 @updatedAt
  assignments      EventSeatMapAssignment[]
  sections         SeatSection[]
  venue            Venue                    @relation(fields: [venueId], references: [id], onDelete: Cascade)

  @@index([venueId])
  @@index([status])
}

model SeatSection {
  id        Int          @id @default(autoincrement())
  seatMapId Int
  name      String
  label     String?
  sortOrder Int?
  metadata  Json?
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
  rows      SeatRow[]
  seatMap   VenueSeatMap @relation(fields: [seatMapId], references: [id], onDelete: Cascade)

  @@unique([seatMapId, name])
  @@index([seatMapId])
}

model SeatRow {
  id        Int            @id @default(autoincrement())
  sectionId Int
  name      String
  label     String?
  sortOrder Int?
  metadata  Json?
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
  seats     SeatPosition[]
  section   SeatSection    @relation(fields: [sectionId], references: [id], onDelete: Cascade)

  @@unique([sectionId, name])
  @@index([sectionId])
}

model SeatPosition {
  id            Int                 @id @default(autoincrement())
  rowId         Int
  seatNumber    String
  displayLabel  String?
  sortOrder     Int?
  isAccessible  Boolean             @default(false)
  isObstructed  Boolean             @default(false)
  metadata      Json?
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  reservedSeats EventReservedSeat[]
  row           SeatRow             @relation(fields: [rowId], references: [id], onDelete: Cascade)

  @@unique([rowId, seatNumber])
  @@index([rowId])
}

model EventSeatMapAssignment {
  id            Int                 @id @default(autoincrement())
  eventId       Int
  seatMapId     Int
  isPrimary     Boolean             @default(false)
  notes         String?
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  reservedSeats EventReservedSeat[]
  event         Event               @relation(fields: [eventId], references: [id], onDelete: Cascade)
  seatMap       VenueSeatMap        @relation(fields: [seatMapId], references: [id], onDelete: Cascade)

  @@unique([eventId, seatMapId])
  @@index([eventId])
  @@index([seatMapId])
}

model EventReservedSeat {
  id                       Int                    @id @default(autoincrement())
  eventSeatMapAssignmentId Int
  seatPositionId           Int
  ticketTypeId             Int?
  status                   SeatAvailabilityStatus @default(available)
  holdExpiresAt            DateTime?
  holdReference            String?
  notes                    String?
  createdAt                DateTime               @default(now())
  updatedAt                DateTime               @updatedAt
  seatMapAssignment        EventSeatMapAssignment @relation(fields: [eventSeatMapAssignmentId], references: [id], onDelete: Cascade)
  seatPosition             SeatPosition           @relation(fields: [seatPositionId], references: [id], onDelete: Cascade)
  ticketType               EventTicketType?       @relation(fields: [ticketTypeId], references: [id])
  tickets                  Ticket?

  @@unique([eventSeatMapAssignmentId, seatPositionId])
  @@index([ticketTypeId])
  @@index([status])
}

model VenueChecklistStatus {
  id              Int                @id @default(autoincrement())
  venueId         Int
  task            VenueChecklistTask
  completedAt     DateTime?
  completedBy     Int?
  completedByUser User?              @relation("VenueChecklistCompletedBy", fields: [completedBy], references: [id])
  venue           Venue              @relation(fields: [venueId], references: [id], onDelete: Cascade)

  @@unique([venueId, task])
  @@index([task])
}

model TicketScan {
  id            Int        @id @default(autoincrement())
  ticketId      String
  scannerUserId Int?
  scannedAt     DateTime   @default(now())
  result        ScanResult
  createdAt     DateTime   @default(now())
  scanner       User?      @relation("Scanner", fields: [scannerUserId], references: [id])
  ticket        Ticket     @relation(fields: [ticketId], references: [id], onDelete: Cascade)
}

model Payment {
  id          String        @id @default(cuid())
  userId      Int?
  ticketId    String?
  amountCents Int
  currency    String
  method      PaymentMethod
  status      PaymentStatus
  externalId  String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  ticket      Ticket?       @relation(fields: [ticketId], references: [id])
  user        User?         @relation(fields: [userId], references: [id])
}

model Charge {
  id              String       @id @default(cuid())
  chargeId        String       @unique
  eventId         Int
  userId          Int?
  ticketId        String?
  ticketTier      String
  quantity        Int
  totalPrice      Decimal      @db.Decimal(10, 2)
  status          ChargeStatus @default(pending)
  transactionHash String?
  walletAddress   String?
  mintedTokenId   String?
  mintRetryCount  Int          @default(0)
  mintLastError   String?
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  event           Event        @relation(fields: [eventId], references: [id])
  ticket          Ticket?      @relation(fields: [ticketId], references: [id])
  user            User?        @relation(fields: [userId], references: [id])

  @@index([chargeId])
  @@index([userId])
  @@index([eventId])
}

model NFTContract {
  id        Int       @id @default(autoincrement())
  chain     String
  address   String    @unique
  name      String?
  symbol    String?
  createdAt DateTime  @default(now())
  mints     NFTMint[]
}

model NFTMint {
  id            String      @id @default(cuid())
  ticketId      String
  contractId    Int
  tokenId       String
  txHash        String?     @unique
  mintedAt      DateTime?
  ownerWalletId Int?
  createdAt     DateTime    @default(now())
  contract      NFTContract @relation(fields: [contractId], references: [id], onDelete: Cascade)
  owner         Wallet?     @relation(fields: [ownerWalletId], references: [id])
  ticket        Ticket      @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@unique([contractId, tokenId])
}

model WaitlistSignup {
  id                 Int               @id @default(autoincrement())
  email              String            @unique @db.Citext
  referralCode       String?           @unique
  referredByCode     String?
  rewards            Int               @default(0)
  walletId           Int?
  notes              String?
  confirmedAt        DateTime?
  createdAt          DateTime          @default(now())
  advocacyCount      Int               @default(0)
  currentTier        String            @default("starter")
  totalVenuesReached Int               @default(0)
  advocacyRequests   AdvocacyRequest[]
  wallet             Wallet?           @relation(fields: [walletId], references: [id])
}

model VenueClick {
  id        Int      @id @default(autoincrement())
  venueId   Int
  url       String
  ip        String?
  userAgent String?
  referrer  String?
  clickedAt DateTime @default(now())
  venue     Venue    @relation(fields: [venueId], references: [id], onDelete: Cascade)
}

model EventImpression {
  id             Int      @id @default(autoincrement())
  eventId        Int
  sessionId      String
  referrer       String?
  clickedThrough Boolean  @default(false)
  createdAt      DateTime @default(now())
  event          Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@index([eventId])
  @@index([sessionId])
  @@index([createdAt])
}

model AdvocacyRequest {
  id             Int            @id @default(autoincrement())
  email          String         @db.Citext
  eventId        Int
  venueName      String
  venueEmail     String?
  userMessage    String?
  emailSent      Boolean        @default(false)
  sentAt         DateTime?
  createdAt      DateTime       @default(now())
  waitlistSignup WaitlistSignup @relation(fields: [email], references: [email])
  event          Event          @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@index([email])
  @@index([eventId])
  @@index([emailSent])
  @@index([createdAt])
}

model VenueMarketingValue {
  id                 Int      @id @default(autoincrement())
  venueName          String   @unique
  venueEmail         String?
  totalImpressions   Int      @default(0)
  totalClicks        Int      @default(0)
  totalAdvocates     Int      @default(0)
  estimatedAdValue   Decimal  @default(0) @db.Decimal(10, 2)
  weeklyImpressions  Int      @default(0)
  monthlyImpressions Int      @default(0)
  lastUpdated        DateTime @default(now())
  createdAt          DateTime @default(now())

  @@index([venueName])
}

model VenueSupportSession {
  id               Int       @id @default(autoincrement())
  userId           Int
  supportedVenueId Int
  startedAt        DateTime  @default(now())
  endedAt          DateTime?
  ipAddress        String?
  userAgent        String?
  createdAt        DateTime  @default(now())
  venue            Venue     @relation("VenueSupportSessions", fields: [supportedVenueId], references: [id], onDelete: Cascade)
  user             User      @relation("VenueSupportSessions", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, endedAt])
  @@index([supportedVenueId])
  @@index([startedAt])
}

model AdminAuditLog {
  id         Int      @id @default(autoincrement())
  userId     Int
  action     String
  targetType String?
  targetId   Int?
  metadata   Json?
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime @default(now())
  user       User     @relation("AdminAuditLogs", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([action, createdAt])
  @@index([targetType, targetId])
}

enum UserRole {
  fan
  artist
  venue
  admin
  dev
}

enum TicketStatus {
  reserved
  minted
  transferred
  refunded
  canceled
  used
  revoked
}

enum PaymentStatus {
  initiated
  authorized
  settled
  failed
  refunded
  canceled
}

enum PaymentMethod {
  fiat_stripe
  usdc_onchain
  eth_onchain
  promo
}

enum ChargeStatus {
  pending
  confirmed
  failed
  delayed
}

enum EventStatus {
  draft
  published
  canceled
  completed
}

enum ScanResult {
  valid
  duplicate
  revoked
  expired
  unknown
}

enum PricingType {
  general_admission
  reserved
  mixed
}

enum SeatMapStatus {
  draft
  active
  archived
}

enum SeatAvailabilityStatus {
  available
  held
  sold
  blocked
}

enum VenueChecklistTask {
  seat_map
  poster_workflow
  staff_accounts
  payout_details
}

// Core auth/users - Extended fields
model UserProfile {
  id                     Int      @id @default(autoincrement())
  userId                 Int      @unique
  notificationsEnabled   Boolean  @default(true)
  emailMarketing         Boolean  @default(false)
  theme                  String   @default("dark") // "dark" | "light"
  language               String   @default("en")
  timezone               String?
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model FavoriteArtist {
  id        Int      @id @default(autoincrement())
  userId    Int
  artistId  Int
  createdAt DateTime @default(now())

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  artist Artist @relation(fields: [artistId], references: [id], onDelete: Cascade)

  @@unique([userId, artistId])
  @@index([userId])
  @@index([artistId])
}

// Venue Staff Management
enum VenueStaffRole {
  OWNER
  MANAGER
  STAFF
  SCANNER
}

model VenueStaff {
  id        Int             @id @default(autoincrement())
  venueId   Int
  userId    Int
  role      VenueStaffRole  @default(STAFF)
  isActive  Boolean         @default(true)
  invitedBy Int?
  invitedAt DateTime        @default(now())
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt

  venue    Venue  @relation(fields: [venueId], references: [id], onDelete: Cascade)
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  inviter  User?  @relation("StaffInviter", fields: [invitedBy], references: [id])

  @@unique([venueId, userId])
  @@index([venueId])
  @@index([userId])
  @@index([role])
  @@index([invitedBy])
}

// Collectable Poster System
model EventPosterVariant {
  id               Int      @id @default(autoincrement())
  eventId          Int
  ticketTypeId     Int?     // null = default for all tiers
  variantName      String   // "VIP Gold", "GA Standard", etc.
  imageUrl         String   // CDN/IPFS URL of generated/uploaded poster
  rarityMultiplier Float    @default(1.0) // 1.0 = GA, 1.5 = Premium, 2.0 = VIP
  generationPrompt String?  @db.Text // AI prompt used (if generated)
  isApproved       Boolean  @default(false)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Refinement tracking (for iterative improvements)
  parentVariantId      Int?                  // Link to original variant that was refined
  parentVariant        EventPosterVariant?   @relation("VariantRefinements", fields: [parentVariantId], references: [id], onDelete: SetNull)
  refinedVariants      EventPosterVariant[]  @relation("VariantRefinements")
  refinementPrompt     String?               @db.Text // Refinement instructions if this is a refined version
  refinementCount      Int                   @default(0) // How many iterations from original (0 = original, 1+ = refined)
  refinementStrength   Float?                // img2img strength used (0.0-1.0)

  event      Event            @relation(fields: [eventId], references: [id], onDelete: Cascade)
  ticketType EventTicketType? @relation(fields: [ticketTypeId], references: [id], onDelete: Cascade)

  @@index([eventId])
  @@index([eventId, ticketTypeId])
  @@index([isApproved])
  @@index([parentVariantId])
}

// Track AI image generation requests for audit and retry
model PosterGenerationRequest {
  id                 Int       @id @default(autoincrement())
  eventId            Int
  venueId            Int
  ticketTypeId       Int?
  prompt             String    @db.Text // User's input + system enhancements
  provider           String    // "stability-ai", "replicate", "openai-dalle", etc.
  status             String    // pending, generating, completed, failed
  resultImageUrl     String?
  errorMessage       String?   @db.Text
  estimatedCostCents Int?
  createdAt          DateTime  @default(now())
  completedAt        DateTime?

  // v2beta API parameters for reproducibility
  model              String?   // 'ultra', 'core', 'sd3'
  aspectRatio        String?   // '1:1', '16:9', '2:3', etc.
  seed               Int?      // Random seed for reproducibility
  outputFormat       String?   // 'png', 'jpeg'

  // Refinement tracking
  parentRequestId        Int?                      // Link to original request that was refined
  parentRequest          PosterGenerationRequest?  @relation("RequestRefinements", fields: [parentRequestId], references: [id], onDelete: SetNull)
  refinements            PosterGenerationRequest[] @relation("RequestRefinements")
  refinementInstructions String?                   @db.Text // Plain English instructions for refinement
  refinementStrength     Float?                    // img2img strength (0.0-1.0)

  event  Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)
  venue  Venue  @relation(fields: [venueId], references: [id], onDelete: Cascade)

  @@index([eventId, status])
  @@index([venueId])
  @@index([status])
  @@index([createdAt])
  @@index([parentRequestId])
}

// Tracks on-chain event registration for NFT minting
model EventBlockchainRegistry {
  id                 Int                              @id @default(autoincrement())
  eventId            Int                              @unique
  onChainEventId     Int                              // Maps to blockchain event ID
  contractAddress    String
  registrationTxHash String
  registeredAt       DateTime
  chainId            Int
  genesisTicketId    String?                          @unique // Points to first test ticket (company archive)
  createdAt          DateTime                         @default(now())
  updatedAt          DateTime                         @updatedAt

  event              Event                            @relation(fields: [eventId], references: [id], onDelete: Cascade)
  genesisTicket      Ticket?                          @relation("GenesisTicket", fields: [genesisTicketId], references: [id])
  tierRegistrations  EventTierBlockchainRegistry[]

  @@index([onChainEventId])
  @@index([contractAddress, chainId])
  @@index([registeredAt])
}

// Tracks on-chain tier registration for each ticket type
model EventTierBlockchainRegistry {
  id                  Int                      @id @default(autoincrement())
  registryId          Int
  ticketTypeId        Int
  onChainTierId       Int                      // Tier ID in the smart contract
  registrationTxHash  String
  registeredAt        DateTime
  createdAt           DateTime                 @default(now())

  registry            EventBlockchainRegistry  @relation(fields: [registryId], references: [id], onDelete: Cascade)
  ticketType          EventTicketType          @relation(fields: [ticketTypeId], references: [id], onDelete: Cascade)

  @@unique([registryId, ticketTypeId])
  @@index([onChainTierId])
  @@index([registeredAt])
}
