// Prisma schema for Unchained, mapped from the ERD in
// Unchained/backend/server/database/README_DB.md

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums
enum UserRole {
  fan
  artist
  venue
  admin
  dev
}

enum TicketStatus {
  reserved
  minted
  transferred
  refunded
  canceled
  used
  revoked
}

enum PaymentStatus {
  initiated
  authorized
  settled
  failed
  refunded
  canceled
}

enum PaymentMethod {
  fiat_stripe
  usdc_onchain
  eth_onchain
  promo
}

enum ChargeStatus {
  pending
  confirmed
  failed
  delayed
}

enum EventStatus {
  draft
  published
  canceled
  completed
}

enum ScanResult {
  valid
  duplicate
  revoked
  expired
  unknown
}

enum PricingType {
  general_admission
  reserved
  mixed
}

enum SeatMapStatus {
  draft
  active
  archived
}

enum SeatAvailabilityStatus {
  available
  held
  sold
  blocked
}

enum VenueChecklistTask {
  seat_map
  poster_workflow
  staff_accounts
  payout_details
}

// Core auth/users
model User {
  id        Int      @id @default(autoincrement())
  name      String?
  email     String   @unique @db.Citext
  role      UserRole @default(fan)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  credentials AuthCredential[]
  sessions    Session[]
  wallets     UserWallet[]
  userRoles   UserRoleLink[]
  artists     Artist[]         @relation("ArtistOwner")
  venues      Venue[]          @relation("VenueOwner")
  tickets     Ticket[]
  scans       TicketScan[]     @relation("Scanner")
  payments    Payment[]
  charges     Charge[]
  completedChecklistItems VenueChecklistStatus[] @relation("VenueChecklistCompletedBy")
}

model AuthCredential {
  id         Int      @id @default(autoincrement())
  userId     Int
  provider   String // e.g., 'password', 'oauth:google', 'siwe'
  identifier String? // external id or email for the provider
  secret     String? // password hash or provider secret
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, provider])
}

model Session {
  id        String   @id @default(cuid())
  userId    Int
  token     String   @unique
  expires   DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// RBAC
model Role {
  id              Int              @id @default(autoincrement())
  name            String           @unique
  rolePermissions RolePermission[]
  userRoles       UserRoleLink[]
}

model Permission {
  id              Int              @id @default(autoincrement())
  name            String           @unique
  rolePermissions RolePermission[]
}

model UserRoleLink {
  userId Int
  roleId Int

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  role Role @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@id([userId, roleId])
}

model RolePermission {
  roleId       Int
  permissionId Int

  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId])
}

// Wallets
model Wallet {
  id        Int      @id @default(autoincrement())
  chain     String
  address   String   @unique
  createdAt DateTime @default(now())

  users           UserWallet[]
  mints           NFTMint[]
  waitlistSignups WaitlistSignup[]
}

model UserWallet {
  userId    Int
  walletId  Int
  isPrimary Boolean  @default(false)
  createdAt DateTime @default(now())

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  wallet Wallet @relation(fields: [walletId], references: [id], onDelete: Cascade)

  @@id([userId, walletId])
}

// Domain: artists, venues, events
model Artist {
  id          Int      @id @default(autoincrement())
  ownerUserId Int?
  name        String
  slug        String   @unique
  genre       String?
  imageUrl    String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  owner      User?         @relation("ArtistOwner", fields: [ownerUserId], references: [id])
  events     Event[]       @relation("PrimaryArtist")
  eventLinks EventArtist[]

  // Performance indexes
  @@index([name]) // For text search
  @@index([genre]) // For genre filtering
}

model Venue {
  id           Int      @id @default(autoincrement())
  ownerUserId  Int?
  name         String
  slug         String   @unique
  city         String?
  state        String?
  capacity     Int?
  addressLine1 String?
  addressLine2 String?
  postalCode   String?
  latitude     Decimal? @db.Decimal(9, 6)
  longitude    Decimal? @db.Decimal(9, 6)
  imageUrl     String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  owner  User?        @relation("VenueOwner", fields: [ownerUserId], references: [id])
  events Event[]
  clicks VenueClick[]
  seatMaps VenueSeatMap[]
  checklistStatuses VenueChecklistStatus[]

  // Performance indexes
  @@index([name]) // For text search
  @@index([city]) // For location filtering
  @@index([state]) // For state filtering
  @@index([city, state]) // Composite for location searches
}

model Event {
  id             Int         @id @default(autoincrement())
  title          String
  startsAt       DateTime
  endsAt         DateTime?
  venueId        Int
  artistId       Int?
  posterImageUrl String?
  externalLink   String?
  mapsLink       String?
  status         EventStatus @default(draft)
  featured       Boolean     @default(false)
  featuredUntil  DateTime?
  viewCount      Int         @default(0)
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  venue         Venue         @relation(fields: [venueId], references: [id], onDelete: Restrict)
  primaryArtist Artist?       @relation("PrimaryArtist", fields: [artistId], references: [id])
  artists       EventArtist[]
  tickets       Ticket[]
  charges       Charge[]
  ticketTypes   EventTicketType[]
  seatMapAssignments EventSeatMapAssignment[]

  // Performance indexes
  @@index([title]) // For text search
  @@index([startsAt]) // For date ordering and filtering
  @@index([status]) // For status filtering
  @@index([venueId]) // For venue lookups
  @@index([artistId]) // For artist lookups
  @@index([startsAt, status]) // Composite for active events
  @@index([featured, startsAt]) // For featured event queries
  @@index([featured, featuredUntil]) // For featured expiry checks
}

model EventArtist {
  eventId   Int
  artistId  Int
  isPrimary Boolean @default(false)
  sortOrder Int?

  event  Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)
  artist Artist @relation(fields: [artistId], references: [id], onDelete: Cascade)

  @@id([eventId, artistId])
}

// Tickets
model Ticket {
  id          String       @id @default(cuid())
  eventId     Int
  userId      Int?
  ticketTypeId Int?
  reservedSeatId Int?
  status      TicketStatus @default(reserved)
  priceCents  Int?
  currency    String?      @default("USD")
  seatSection String?
  seatRow     String?
  seat        String?
  qrHash      String?      @unique
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  event    Event        @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user     User?        @relation(fields: [userId], references: [id])
  ticketType EventTicketType? @relation(fields: [ticketTypeId], references: [id], onDelete: SetNull)
  reservedSeat EventReservedSeat? @relation(fields: [reservedSeatId], references: [id], onDelete: SetNull)
  scans    TicketScan[]
  payments Payment[]
  mints    NFTMint[]
  charges  Charge[]

  @@unique([eventId, seatSection, seatRow, seat])
  // Performance indexes
  @@index([eventId]) // For event ticket lookups
  @@index([userId]) // For user ticket lookups
  @@index([status]) // For status filtering
  @@index([eventId, status]) // Composite for event ticket status
  @@index([ticketTypeId])
  @@unique([reservedSeatId])
}

model EventTicketType {
  id          Int          @id @default(autoincrement())
  eventId     Int
  name        String
  description String?
  pricingType PricingType  @default(general_admission)
  priceCents  Int?
  currency    String       @default("USD")
  capacity    Int?
  salesStart  DateTime?
  salesEnd    DateTime?
  isActive    Boolean      @default(true)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  event        Event             @relation(fields: [eventId], references: [id], onDelete: Cascade)
  tickets      Ticket[]
  reservedSeats EventReservedSeat[]

  @@index([eventId])
  @@index([pricingType])
  @@index([isActive])
}

model VenueSeatMap {
  id               Int           @id @default(autoincrement())
  venueId          Int
  name             String
  description      String?
  status           SeatMapStatus @default(draft)
  version          Int           @default(1)
  storagePath      String?
  originalFileName String?
  mimeType         String?
  structure        Json?
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  venue      Venue                     @relation(fields: [venueId], references: [id], onDelete: Cascade)
  sections   SeatSection[]
  assignments EventSeatMapAssignment[]

  @@index([venueId])
  @@index([status])
}

model SeatSection {
  id         Int      @id @default(autoincrement())
  seatMapId  Int
  name       String
  label      String?
  sortOrder  Int?
  metadata   Json?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  seatMap VenueSeatMap @relation(fields: [seatMapId], references: [id], onDelete: Cascade)
  rows    SeatRow[]

  @@index([seatMapId])
  @@unique([seatMapId, name])
}

model SeatRow {
  id         Int      @id @default(autoincrement())
  sectionId  Int
  name       String
  label      String?
  sortOrder  Int?
  metadata   Json?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  section SeatSection   @relation(fields: [sectionId], references: [id], onDelete: Cascade)
  seats   SeatPosition[]

  @@index([sectionId])
  @@unique([sectionId, name])
}

model SeatPosition {
  id           Int      @id @default(autoincrement())
  rowId        Int
  seatNumber   String
  displayLabel String?
  sortOrder    Int?
  isAccessible Boolean  @default(false)
  isObstructed Boolean  @default(false)
  metadata     Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  row           SeatRow            @relation(fields: [rowId], references: [id], onDelete: Cascade)
  reservedSeats EventReservedSeat[]

  @@index([rowId])
  @@unique([rowId, seatNumber])
}

model EventSeatMapAssignment {
  id        Int      @id @default(autoincrement())
  eventId   Int
  seatMapId Int
  isPrimary Boolean @default(false)
  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  event   Event        @relation(fields: [eventId], references: [id], onDelete: Cascade)
  seatMap VenueSeatMap @relation(fields: [seatMapId], references: [id], onDelete: Cascade)
  reservedSeats EventReservedSeat[]

  @@index([eventId])
  @@index([seatMapId])
  @@unique([eventId, seatMapId])
}

model EventReservedSeat {
  id                         Int                     @id @default(autoincrement())
  eventSeatMapAssignmentId   Int
  seatPositionId             Int
  ticketTypeId               Int?
  status                     SeatAvailabilityStatus @default(available)
  holdExpiresAt              DateTime?
  holdReference              String?
  notes                      String?
  createdAt                  DateTime                @default(now())
  updatedAt                  DateTime                @updatedAt

  seatMapAssignment EventSeatMapAssignment @relation(fields: [eventSeatMapAssignmentId], references: [id], onDelete: Cascade)
  seatPosition     SeatPosition           @relation(fields: [seatPositionId], references: [id], onDelete: Cascade)
  ticketType       EventTicketType?       @relation(fields: [ticketTypeId], references: [id], onDelete: SetNull)
  tickets          Ticket[]

  @@unique([eventSeatMapAssignmentId, seatPositionId])
  @@index([ticketTypeId])
  @@index([status])
}

model VenueChecklistStatus {
  id           Int                 @id @default(autoincrement())
  venueId      Int
  task         VenueChecklistTask
  completedAt  DateTime?
  completedBy  Int?

  venue             Venue @relation(fields: [venueId], references: [id], onDelete: Cascade)
  completedByUser   User? @relation("VenueChecklistCompletedBy", fields: [completedBy], references: [id])

  @@unique([venueId, task])
  @@index([task])
}

model TicketScan {
  id            Int        @id @default(autoincrement())
  ticketId      String
  scannerUserId Int?
  scannedAt     DateTime   @default(now())
  result        ScanResult
  createdAt     DateTime   @default(now())

  ticket  Ticket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  scanner User?  @relation("Scanner", fields: [scannerUserId], references: [id])
}

// Payments
model Payment {
  id          String        @id @default(cuid())
  userId      Int?
  ticketId    String?
  amountCents Int
  currency    String
  method      PaymentMethod
  status      PaymentStatus
  externalId  String? // Stripe PI id or onchain tx id
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  user   User?   @relation(fields: [userId], references: [id])
  ticket Ticket? @relation(fields: [ticketId], references: [id])
}

model Charge {
  id              String       @id @default(cuid())
  chargeId        String       @unique
  eventId         Int
  event           Event        @relation(fields: [eventId], references: [id])
  userId          Int?
  user            User?        @relation(fields: [userId], references: [id])
  ticketId        String?
  ticket          Ticket?      @relation(fields: [ticketId], references: [id])
  ticketTier      String
  quantity        Int
  totalPrice      Decimal      @db.Decimal(10, 2)
  status          ChargeStatus @default(pending)
  transactionHash String?
  walletAddress   String?
  mintedTokenId   String?
  mintRetryCount  Int          @default(0)
  mintLastError   String?
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt

  @@index([chargeId])
  @@index([userId])
  @@index([eventId])
}

// NFTs
model NFTContract {
  id        Int      @id @default(autoincrement())
  chain     String
  address   String   @unique
  name      String?
  symbol    String?
  createdAt DateTime @default(now())

  mints NFTMint[]
}

model NFTMint {
  id            String    @id @default(cuid())
  ticketId      String
  contractId    Int
  tokenId       String
  txHash        String?   @unique
  mintedAt      DateTime?
  ownerWalletId Int?
  createdAt     DateTime  @default(now())

  ticket   Ticket      @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  contract NFTContract @relation(fields: [contractId], references: [id], onDelete: Cascade)
  owner    Wallet?     @relation(fields: [ownerWalletId], references: [id])

  @@unique([contractId, tokenId])
}

// Growth / waitlist
model WaitlistSignup {
  id             Int       @id @default(autoincrement())
  email          String    @unique @db.Citext
  referralCode   String?   @unique
  referredByCode String?
  rewards        Int       @default(0)
  walletId       Int?
  notes          String?
  confirmedAt    DateTime?
  createdAt      DateTime  @default(now())

  wallet Wallet? @relation(fields: [walletId], references: [id])
}

// Analytics
model VenueClick {
  id        Int      @id @default(autoincrement())
  venueId   Int
  url       String
  ip        String?
  userAgent String?
  referrer  String?
  clickedAt DateTime @default(now())

  venue Venue @relation(fields: [venueId], references: [id], onDelete: Cascade)
}
